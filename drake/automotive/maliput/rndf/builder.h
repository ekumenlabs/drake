#pragma once

#include <algorithm>
#include <cmath>
#include <map>
#include <memory>
#include <set>
#include <string>
#include <tuple>
#include <vector>
#include <iostream>

#include "ignition/math/Vector3.hh"
#include "ignition/math/Spline.hh"
#include "ignition/rndf/UniqueId.hh"

#include "drake/automotive/maliput/api/lane_data.h"
#include "drake/automotive/maliput/rndf/junction.h"
#include "drake/common/drake_assert.h"
#include "drake/common/drake_throw.h"
#include "drake/common/drake_copyable.h"

namespace drake {
namespace maliput {

namespace rndf {
class RoadGeometry;

/// This is a wrapper of a ignition::rndf::Waypoint class that add some useful
/// properties to compute the lanes from them.
class DirectedWaypoint {
 public:
  DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(DirectedWaypoint)
  /// Default constructor.
  DirectedWaypoint() = default;
  /// Constructor.
  ///
  /// @param id is the ID of the RNDF waypoint. It may be generated by the
  /// Builder or just be a copy of what has been parsed with ignition::rndf.
  /// @param position is the 3D coordinates of the control_point in the
  /// GeoPosition frame.
  /// @param is_entry is a boolean that tells wether or not the original RNDF
  /// waypoint acts as an entry for the RNDF lane.
  /// @param is_exit is a boolean that tells wether or not the original RNDF
  /// waypoint acts as an entry for the RNDF lane.
  /// @param tangent is a vector that tells the direction of the lane at this
  /// @p position.
  DirectedWaypoint(
      const ignition::rndf::UniqueId& id,
      const ignition::math::Vector3d& position,
      const bool is_entry = false,
      const bool is_exit = false,
      const ignition::math::Vector3d& tangent = ignition::math::Vector3d::Zero)
      : id_(id), position_(position), tangent_(tangent), is_entry_(is_entry),
        is_exit_(is_exit) { }

  const ignition::rndf::UniqueId& id() const { return id_; }
  const ignition::math::Vector3d& position() const { return position_; }
  const ignition::math::Vector3d& tangent() const { return tangent_; }
  ignition::math::Vector3d& tangent() { return tangent_; }
  bool is_entry() const { return is_entry_; }
  bool is_exit() const { return is_exit_; }

  /// It gets the bounding box based on a vector of @p directed_waypoints. It
  /// just gets the minimum and maximum coordinate x and y from all the items.
  /// z coordinate must be always zero as this is a flat map.
  static std::tuple<ignition::math::Vector3d, ignition::math::Vector3d>
  CalculateBoundingBox(const std::vector<DirectedWaypoint>& directed_waypoints);

 private:
  ignition::rndf::UniqueId id_;
  ignition::math::Vector3d position_;
  ignition::math::Vector3d tangent_;
  bool is_entry_ {false};
  bool is_exit_ {false};
};

/// Representation of a reference path used to construct a Lane from a
/// collection of DirectedWaypoints.
class Connection {
 public:
  DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(Connection)

  /// Default constructor
  Connection() = default;

  /// Constructs a Connection.
  ///
  /// @param id is the ID of the connection.
  /// @param waypoints is a vector of DirectedWaypoints that determines the path
  /// of the lane.
  /// @param width is the width of the future Lane or Lanes.
  /// @param inverse_direction is a bool that keeps track of the relative sense
  /// of direction of this Connection against others. RNDF lanes have an
  /// implicit direction based on how waypoints are described.
  /// @throws in case the size @p waypoints is less than 2.
  Connection(const std::string& id,
    const std::vector<DirectedWaypoint>& waypoints,
    const double width,
    const bool inverse_direction = false) : id_(id),
      waypoints_(waypoints),
      width_(width),
      inverse_direction_(inverse_direction) {
    DRAKE_THROW_UNLESS(waypoints_.size() >= 2);
  }

  /// @return the @p id string.
  const std::string& id() const { return id_; }

  /// @return a constant reference to the first item of @p waypoints
  const DirectedWaypoint& start() const { return waypoints_.front(); }
  /// @return a mutable reference to the first item of @p waypoints
  DirectedWaypoint& start() { return waypoints_.front(); }

  /// @return a constant reference to the last item of @p waypoints
  const DirectedWaypoint& end() const { return waypoints_.back(); }
  /// @return a mutable reference to the last item of @p waypoints
  DirectedWaypoint& end() { return waypoints_.back(); }

  /// @return a constant reference to @p waypoints
  const std::vector<DirectedWaypoint>& waypoints() const { return waypoints_; }
  /// @return a mutable reference to @p waypoints
  std::vector<DirectedWaypoint>& waypoints() { return waypoints_; }

  /// @return @p width
  double width() const { return width_; }
  /// Setter of @p width
  void set_width(const double width) { width_ = width; }

  /// @return @p inverse_direction
  bool inverse_direction() const { return inverse_direction_; }
  /// Setter of @p inverse_direction
  void set_inverse_direction(const bool inverse_direction) {
    inverse_direction_ = inverse_direction;
  }

 private:
  std::string id_;
  std::vector<DirectedWaypoint> waypoints_;
  double width_ {};
  bool inverse_direction_{false};
};

/// It is wrapper to construct a api::RoadGeometry from Connections and
/// waypoints.
/// Lanes are based on SplineLanes which follow a spline geometry whose
/// implementation uses ignition::math::Spline class.
/// RNDF segments, and lanes are mapped to the conception of
/// maliput::api::Segment and maliput::api::Lane classes which have some
/// differences. The main concept of RNDF is that it defines logical connections
/// in terms of waypoints. Maliput conception of segments and lanes are based on
/// a geometric basis. The spline is the proposed geometry as it is a C1 curve
/// and matches the requisites.
/// Besides, RNDF segments are used just as a hint on how to group
/// Maliput lanes. @see CreateSegmentConnections for more details.
/// RNDF zones do not have a direct mapping to Maliput. So just road connections
/// are constructed to let the entire api::RoadGeometry be driveable.
/// @see CreateConnectionsForZones for more details.
///
/// General workflow with this class should be:
/// -# Create a Builder
/// -# Call SetBoundingBox
/// -# Call CreateSegmentConnections for each RNDF segment.
/// -# Call CreateConnectionsForZones for each RNDF zone.
/// -# Call CreateConnection for each pair of entry-exit in RNDF lanes and
/// perimeters.
/// -# Call Build to get your api::RoadGeometry
class Builder {
 public:
  DRAKE_NO_COPY_NO_MOVE_NO_ASSIGN(Builder)

  /// Constructs a Builder which can be used to specify and assemble a
  /// RNDF implementation of an api::RoadGeometry.
  ///
  /// @param linear_tolerance is a parameter to construct the api::RoadGeometry
  /// @param angular_tolerance is a parameter to construct the api::RoadGeometry
  Builder(const double linear_tolerance, const double angular_tolerance)
    : linear_tolerance_(linear_tolerance),
    angular_tolerance_(angular_tolerance) {}

  /// It sets the bounding box of the RNDF map.
  ///
  /// @param bounding_box is a tuple whose first value is the minimum corner of
  /// the bounding box and the second one is the maximum corner.
  void SetBoundingBox(const std::tuple<ignition::math::Vector3d,
      ignition::math::Vector3d>& bounding_box) {
    bounding_box_ = bounding_box;
  }

  /// It will adapt the @p lanes to based on the induced geometry that can be
  /// generated from them. The @p lanes vector is a collections of Connections
  /// that describe the RNDF collection of waypoints with their positions
  /// already converted to the api::GeoPosition frame.
  /// First we need to check if the lanes go all to the same direction so as we
  /// can define a unique order from right to left. Once the order is defined we
  /// create a local map of Connections that is used later to create the Maliput
  /// Segment and Lane. For each group, we project the DirectedWaypoints on the
  /// other Connection to have matching pieces of lanes in the same Segment.
  /// Those projections will end up as new DirectedWaypoints. We take the
  /// information of the generated splines to get the interpolated positions and
  /// tangents. Afterwards, we need to order the connections from right to left
  /// and then add the final Connection objects to the intance map @p
  /// connections_
  ///
  /// @param segment_id is the RNDF id of the segment.
  /// @param lanes is a vector of connections used to construct the Maliput
  /// entities.
  void CreateSegmentConnections(const uint segment_id,
    std::vector<Connection>* lanes);

  /// It will create a collection of roads from all the entries to all the exits
  /// in @p perimeter_waypoints. RNDF defines zones as areas where free driving
  /// can be achieved. As in Maliput we don't have that concept, we create
  /// specific make the zone driveable and connect the incomming and outgoing
  /// paths.
  /// Tangents on DirectedWaypoints are set so as to head the mean coordinate
  /// from all the @p perimeter_waypoints items.
  ///
  /// @param width is the width to assign to the lanes.
  /// @param perimeter_waypoints is a collenction of waypoints to create the
  /// RNDF zone paths.
  void CreateConnectionsForZones(const double width,
    std::vector<DirectedWaypoint>* perimeter_waypoints);

  /// Loads a connections between two RNDF lanes based on a set of @p exit and
  /// @p entry ids that map to a specific DirectedWaypoint object.
  ///
  /// @param width is the width of the connection.
  /// @param exit is the DirectedWaypoint::id value.
  /// @param entry is the DirectedWaypoint::id value.
  /// @throws in case either exit or entry ids where not set before.
  void CreateConnection(const double width,
                        const ignition::rndf::UniqueId& exit,
                        const ignition::rndf::UniqueId& entry);

  /// @param id is the ID of the api::RoadGeometry
  /// @return an api::RoadGeometry
  std::unique_ptr<const api::RoadGeometry> Build(const api::RoadGeometryId& id);

 private:
  std::string BuildName(const ignition::rndf::UniqueId& id) const;

  void CreateLane(const std::string& key_id, const double width,
                  const std::vector<DirectedWaypoint>& control_points);

  void AttachLaneEndToBranchPoint(Lane* lane, const api::LaneEnd::Which end,
                                  BranchPoint* branch_point);

  void BuildOrUpdateBranchpoints(
      Connection* connection, Lane* lane,
      std::map<std::string, BranchPoint*>* branch_point_map,
      RoadGeometry* road_geometry);

  Lane* BuildConnection(Segment* segment, const Connection* connection);

  // Given a vector of DirectedWaypoint, it will construct and
  // return std::unique_ptr<ignition::math::Spline>. If any of the id_ of
  // the waypoints is not valid, it won't be taken into account.
  std::unique_ptr<ignition::math::Spline>
  CreateSpline(const std::vector<DirectedWaypoint>* waypoints);

  std::unique_ptr<ignition::math::Spline> CreatePChip(
    const std::vector<DirectedWaypoint>* waypoints);

  // Given the waypoints of the lanes and index which is the item
  // from zero to pick on each vector and test the distance against all the
  // other lanes. Basically, it will look for a waypoint which is first in the
  // s direction and return a @return vector containing all the lane indixes
  // that are at the same s length from the first one. In case all the lanes
  // are at the same position, none of them is returned.
  std::vector<int> GetInitialLaneToProcess(std::vector<Connection>* lanes,
                                           const int index);

  /// It loads the tangents into each of the waypoints using
  /// @function CreateSpline API.
  void BuildTangentsForWaypoints(std::vector<DirectedWaypoint>* waypoints);

  /// It computes a vector that joins base to destiny and then computes
  /// the projection of it against base tangent. It returns a double with
  /// that value
  double ComputeDistance(const DirectedWaypoint& base,
                         const DirectedWaypoint& destiny) const;

  /// It checks if we need to add a dummy or an interpolated waypoint on the
  /// lanes given the ids of the lanes that have for index a control
  /// point before the others.
  void AddWaypointIfNecessary(const std::vector<int>& ids,
                              std::vector<Connection>* lanes, const int index);

  /// It is the base function that wraps all the process of adding waypoints
  /// when necessary for the lanes.
  /// It will throw std::runtime_error if lanes vector is nullptr or if any
  /// of the called functions constraints are not met.
  void CreateNewControlPointsForLanes(std::vector<Connection>* lanes);

  /// This function checks the list of lanes their waypoints
  /// and copies all the waypoints at index position from lane_ids
  /// respective lanes. Then, it orders them following the direction of each
  /// control point from right to left. It will return lane_ids with the
  /// correct order of the ids. In case lane_ids is nullptr or its size is 0
  /// it will throw std::runtime_error. If the size of lane_ids just one, it
  /// will return without doing anything.
  void OrderLaneIds(std::vector<Connection>* lanes, std::vector<int>* lane_ids,
                    const int index);

  // It calculates the momentum of wp against point with normalized tangent
  // value. As all the DirectedWaypoints are thought to be on the x-y play, the
  // z value of the cross product is returned.
  double CalculateMomentum(const ignition::math::Vector3d& point,
                           const DirectedWaypoint& wp);
  // It calculates the momenumt of all the DirectedWaypoints in wps against
  // base_point.
  // It returns the sum of all the CalculateMomentum results.
  double CalculateConnectionMomentum(const ignition::math::Vector3d& base_point,
                                     const std::vector<DirectedWaypoint>& wps);

  // It calls CalculateConnectionMomentum for each lane in lanes. Then it checks
  // the sign of the momentum of each lane to determine the "way" that each lane
  // follows and make a reference against the first item on the vector.
  void SetInvertedLanes(std::vector<Connection>* lanes);

  // It will return the intesection point of the normal line that intersects the
  // position of base and the projection of the tangent of other_lane_base.
  ignition::math::Vector3d
  ConstructPointForLane(const DirectedWaypoint& base,
                        const DirectedWaypoint& other_lane_base) const;

  // It groups the lanes based on their direction and fills segments map with
  // those groups.
  void GroupLanesByDirection(const std::vector<Connection>* lanes,
    std::map<int, std::vector<Connection>>* segments) const;

  const double linear_tolerance_ {};
  const double angular_tolerance_ {};
  std::map<std::string, std::vector<std::unique_ptr<Connection>>> connections_;
  std::map<std::string, DirectedWaypoint> directed_waypoints_;
  std::tuple<ignition::math::Vector3d, ignition::math::Vector3d> bounding_box_;
  static const double kWaypointDistancePhase;
  static const double kLinearStep;
};

}  // namespace rndf
}  // namespace maliput
}  // namespace drake
